\chapter{Implementation}\label{impl}
In this section we discuss the implementation details of CudaMONSEL.

The simulation is divided into two main packages, microanalysis and nanoanalysis, based on their respective functionalities and thus, authors. The microanalysis package, authored by Nicholas Ritchie, deals primarily with x--ray analysis, while the nanoanalysis package, authored by John Villarrubia, focuses on electron's interactions with materials. While their applications are different, nanoanalysis depends on microanalysis' implementation (mostly geometry) to work. We will introduce both sections below, with an emphasis on the connections between the two packages.

\section{Microanalysis}
In this package, the physics of the simulation are provided by subclasses of \emph{AlgorithmUser} and \emph{AlgorithmClass} abstract classes.

\subsection{Algorithm Classes}
This section is dedicated to the implementation details of classes that are related the physics of the simulation. All of these classes are derived from the abstract base class algorithm 

The main purpose of \emph{AlgorithmUser} class is to provide the abstract method \emph{initializeDefaultStrategy} which provides a function shared by its subclasses to set each class in a proper state required to run the physics. 

The secondary purpose of this class is to provide a place for the simulation to define the default algorithms to use when none is specified. This is enabled by the \emph{Strategy} class.

The \emph{AlgorithmClass} abstract class inherits from \emph{AlgorithmUser} abstract class and included more information about the source of the physics algorithm (eg author). It also provides a way to query all physical algorithms of the same type (TODO: explain CLEARLY) via the \emph{getAllImplementations} abstract method.

\subsubsection{}

\section{Simulation}\label{impl:sim}
The simulation computes the movement of the electron for each unit of time step. First, it acquires the active electron's position. From the position info, it calculates the current active region and the associated material scattering model. To obtain the position of electron at the next time step, the simulation acquires a random mean path length of the electron based on the scattering model and computes the electron's position at next time step. With the new position, the simulation obtains the next region, moves the electron and decreases its energy. Finally, it perfoems a check to determine if the active electron's trajectory is completed. If the trajectory is not completed, the simulation performs one of three actions based on the next region. At each time step, the energy loss and position of the electron is updated. When a new electron is spawned, the original electron is stored on a stack until the new electron is destroyed when its energy falls below the tracking threshold of the scattering mechanism. Refer to function \emph{takeStep} in MonteCarloSS.cu for details. 

\section{Material}\label{impl:mat}
\subsection{Material}
\subsection{Secondary Eleectron Material}

\section{Barrier Scattering Mechanism}\label{impl:barrier_sm}
\begin{lstlisting}[caption={BarrierScatterMechanism.cuh},label={lst:barrierSM},numbers=left,escapeinside={@}{@}]
class BarrierScatterMechanism
{
public:
   virtual ElectronT* barrierScatter(ElectronT* pe, const RegionBaseT* nextRegion) const = 0;
};
\end{lstlisting}

The barrier scatter mechanism follows the abstract class shown in \ref{lst:barrierSM}.

\subsection{Exponential Quantum Mechanical Barrier Scatter Mechanism}
A barrier scattering mechanism is associated with each region of our sample, but barrier transmission is a pair-wise phenomenon. That is, the barrier height and width at an interface between materials A and B depends in principle upon the properties of both materials. If the electron starts inside material A, then it is material A's barrier scatter mechanism that governs that particular scattering event. The present scatter mechanism determines the barrier height by comparing the potential energies in the materials on each side of the interface. It uses the barrier width associated with material A. This scattering mechanism uses the property energyCBbottom, which therefore need to be properly defined for the materials on both sides of the interface.

This class computes barrier transmission using the formula provided by \cite{Landau}. Note that this is the only barrier SM available in the JMONSEL package. 

\section{Scatter Mechanism}\label{impl:sm}
\begin{lstlisting}
class ScatterMechanism
{
public:
   /**
    * Returns the reciprocal of the mean free path.
    *
    * @param pe - the primary electron
    * @return double Reciprocal of mfp in inverse meters
    */
   virtual double scatterRate(Electron pe) = 0;

   /**
    * Updates properties of the primary electron based on results of scattering and returns either a secondary electron or null.
    * @param pe -- the primary electron
    * @return Electron -- the generated secondary electron or null
    */
   virtual Electron scatter(Electron pe) = 0;

   /**
    * Sets the material within which the electron scatters. This method typically precomputes and caches combinations of material properties required by the scattering model.
    * @param mat
    */
   virtual void setMaterial(Material mat) = 0;
}
\end{lstlisting}

Scatter mechanisms included in JMONSEL are:
\begin{enumerate}
\item BrowningMottElasticSM
\item FittedInelSM
\item GanachaudMokraniPhononInelasticSM
\item GanachaudMokraniPolaronTrapSM
\item KoteraPlasmonInelasticSM
\item MollerInelasticSM
\item SelectableElasticSM
\item TabulatedInelasticSM
\end{enumerate}

\section{Randomized Scatter}
The type of randomized scatter depends on the the energy of the electron.

\subsection{CzyzewskiMottCrossSection}
\subsection{BrowningEmpiricalCrossSection}
Browning empirical cross section is applicable to low energy (\<100eV) electrons. 
\begin{align*}
   CS(Z, e) &= \frac{3e-22 Z^{1.7}}{e + 0.005 Z^{1.7} \sqrt{e} + 0.0007 Z^{2} / \sqrt{e}}
\end{align*}
where $e$ is electron energy in keV, $Z$ is the proton number of the element.

\begin{align*}
    SA(Z, e)= 
\begin{cases}
    acos\left (1.0 - \frac{2.0 \alpha r_2}{\alpha - r_2 + 1}\right ),& \text{if } r_1 \leq \frac{r}{r+1}\\
    acos(1-2.0r_2),& \text{otherwise}
\end{cases}
\end{align*}
where $\alpha = 7.0e-3/e$, $r_1, r_2 \text{are random numbrs} \in \[0, 1\]$, and $r = (300.0 * e / Z) + (Z^3 / 3.0e5 * e)$.

\subsection{ScreenedRutherfordScatteringAngle}
Browning empirical cross section is applicable to high energy (\>20keV) electrons. 
\begin{align*}
   CS(Z, e) &= \frac{7.670843088080456e-38 zp (1.0 + z)}{e + 5.44967975966321e-19 zp^2}
\end{align*}
where $e$ is the electron energy in keV, $Z$ is the proton number, and $zp = Z^{1.0/3.0}$.

\begin{align*}
    SA(Z, e) &= acos\frac{1 - 2.0 * alpha * r}{1 + alpha - r}
\end{align*}
where $\alpha = 5.44968e-19 Z^{2.0 / 3.0} / e$, $r \text{is a random numbrs} \in \[0, 1\]$.

\subsection{NISTMottScatteringAngle}
\subsection{NISTMott}
NISTMott randomized scatter tries to provide a comprehensive model for all energy ranges. For low energy, it uses the Browning empirical scattering angle while for high energy, the screened Rutherford scattering angle. For energy between $100eV$ and $20keV$, it interpolates from a table built with the NIST SRD 64 method (TODO??) with Lagrange interpolation.

\begin{appendices}
\chapter{Lagrange Interpolation}
Given $n+1$ points $(x_0, y_0)$, ... $(x_n, y_n)$, the Lagrange Interpolation is given by 
\begin{align*}
    f_n(x) = \sum^{n}_{i=0} L_i(x)f(x_i)
\end{align*}
where $f(x_i) = y_i$ and $L_i(x)=\prod_{j=0,j\ne i}^{n}\frac{x-x_j}{x_i-x_j}$.
\end{appendices}

NISTMottScatteringAngle uses 2nd order interpolation in $log(E)$ for the totalCrossSection calculation. For randomScatteringAngle it uses 0th order interpolation (i.e., it chooses the nearest tabulated value) in $log(E)$ and 1st order in the random number. In contrast the present class uses 3rd order for all interpolations. Orders can be set by the constants \textit{qINTERPOLATIONORDER} and \textit{sigmaINTERPOLATIONORDER}.

$mSpwem$ is a 1--d table of total cross sections, uniform in $log(E)$ from $log(50.)$ to $log(20000)$
$mX1[j][i]$ is a 2--d table of $q$ vs $Log(E)$ and random \#. $j$ indexes $log(E)$. $i$ indexes $r$. $q$ is related to $cos(\theta)$ by $1-2q^2=cos(theta)$.

\begin{align*}
   CS(Z, e) =
   \begin{cases}
      \text{browning SA}, \text{if } e \lt 
   \end{cases}
\end{align*}
where $e$ is electron energy in keV, $Z$ is the proton number of the element.

\begin{align*}
    SA(Z, e)= 
\begin{cases}
    acos\left (1.0 - \frac{2.0 \alpha r_2}{\alpha - r_2 + 1}\right ),& \text{if } r_1 \leq \frac{r}{r+1}\\
    acos(1-2.0r_2),              & \text{otherwise}
\end{cases}
\end{align*}
where $\alpha = 7.0e-3/e$, $r_1, r_2 \text{are random numbrs} \in \[0, 1\]$, and $r = (300.0 * e / Z) + (Z^3 / 3.0e5 * e)$.

\section{Slowing Down Algorithm}\label{impl:sda}
\begin{lstlisting}
public interface SlowingDownAlg {
   /**
    * Sets the material for which the energy loss is to be computed
    *
    * @param mat
    */
   void setMaterial(SEmaterial mat);

   /**
    * compute - Computes the energy change for an electron with initial energy
    * eK traversing distance d. The return value is negative if the electron
    * loses energy.
    *
    * @param d double -- the distance moved by the electron
    * @param pe Electron, the primary electron
    * @return double -- the energy change
    */
   double compute(double d, Electron pe);
}
\end{lstlisting}
\subsection{Joy--Lou--Nieminen}

\section{Events}\label{impl:events}
The event listener `hooks' onto the simulation and provides a way to transfer information out of the simulation loop. This means that event listeners are by design passive and unable to affect the outcome of the simulations. The simulation will work even when all event--related code are removed, in which case some other mean of acquiring simulation state needs to be implemented if one wishes to retrieve any information about the on--going simulation.

The following events are defined inside $MonteCarloSS$ class:
\begin{enumerate}
\item ScatterEvent
\item NonScatterEvent
\item BackscatterEvent
\item ExitMaterialEvent
\item TrajectoryStartEvent
\item TrajectoryEndEvent
\item LastTrajectoryEvent
\item FirstTrajectoryEvent
\item StartSecondaryEvent
\item EndSecondaryEvent
\item PostScatterEvent
\item BeamEnergyChanged
\end{enumerate}

\subsection{Detector}\label{subsec:detector}
The most important events of are events relating to detecting backscattered electrons. Detectors are devices that collect the information about electrons for later processing. In the simulation, electrons that are characterized as secondary electrons are backscattered electrons with energy below $50 eV$. To simulate the detector, backscatter events are used. Backscatter events are fired only when the electron hits the chamber wall (one of the three normal end states of a electron). If required, we may also obtain forward--scattered secondary electrons for TEM image simulations.

Concretely, the event listener must be added to the simulation class (ie $MonteCarloSS$), before the start of the simulation, and have member function $actionPerformed$ of the listener classes added to the simulation deal with the appropriate events. Note that, the simulation broadcasts the event triggered to all listener classes by calling the member function $actionPerformed$ of every listener class added to the simulation in the function $fireEvent$.

\section{Amphibian -- custom C++ library}
Since one of the goals of the project is to make MONSEL compiler--independent, we built a custom library to minimize dependence on the C++ standard template library (STL). The following data structures are included,
\begin{enumerate}
\item linkedlist (single-- and double--linked)
\item vector
\item stack
\item unordered set
\item unordered map
\item (mutable) string
\end{enumerate}

Algorithms like quick sort, binary search are also included. There is also a random class responsible for generating random numbers reliably.
